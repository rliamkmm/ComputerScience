[< 뒤로](../README.md)

## 컴퓨터 시스템 구조
- 운영체제에 앞서 컴퓨터 시스템에서 하드웨어가 어떻게 동작하고, 그 하드웨어 위에서 어떻게 프로그램이 돌아가는지를 알아보자.

<p align="center"><img src = "https://user-images.githubusercontent.com/67847920/152648930-5bfe9b36-bb7e-47dc-a2e0-2acdc81ea555.PNG" width="600"></p>  


### Computer : CPU + Memory
- **CPU** : PC가 가리키는 주소의 Memory로부터 명령을 인출하여 실행
    - **Register** : 데이터를 저장할 수 있는 작은 공간으로 메모리보다 빠르다.
    - **Mode bit** : CPU가 OS를 실행하는지 사용자 프로그램을 실행하는지 구분해주는 역할
        - 0: **커널 모드**, CPU가 OS를 실행 중. 보안을 해칠 수 있는 중요한 명령을 포함해 모든 명령을 수행할 수 있다. 그래서 다른 사용자 프로그램의 메모리 접근 뿐만 아니라 I/O Device 접근을 위한 명령도 실행을 할 수 있다.
          사용자 프로그램 실행 중에 인터럽트나 예외 발생시 CPU 제어권이 OS로 넘어가면서 하드웨어가 Mode bit을 0으로 바꾼다.
        - 1: **사용자 모드**, CPU가 사용자 프로그램을 실행 중. 메모리 접근과 관련된 제한된 일반 명령만 CPU에서 수행이 가능하다.
          OS가 사용자 프로그램에게 CPU를 넘길 때 mode bit을 1로 바꾸어서 전달한다. 그러면 명령 실행중 I/O 장치 접근하거나 다른 프로그램 또는 OS 메모리 공간 접근 시도시
          mode bit을 보고 명령 실행을 하드웨어적으로 막는다.
        - 이처럼 Mode bit은 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치이다.
    - **Interrupt line** : 주변 장치가 인터럽트를 세팅할 때 사용하는 것. CPU가 인터럽트 여부를 확인하기 위해 실행중인 명령이 끝날 때마다, Interrupt line을 확인하여 인터럽트가 들어왔는지 체크한다.
        - 인터럽트 발생 예시
            - 1. Device I/O  
                 CPU는 오직 메모리에만 접근한다. CPU는 항상 메모리에 있는 명령어를 읽어서 실행하는데, 프로그램의 경우에 따라 수행중에 키보드 입력이나 모니터 출력, 또는 디스크 작업과 같은 device I/O 작업이 필요할 수 있다.
                 그러한 시점에 온 경우, 사용자 프로그램은 시스템콜을 통해 OS로 I/O를 해달라는 요청과 함께 인터럽트 라인을 세팅하고(트랩), CPU를 OS로 넘긴다. 이유는 I/O Device에 접근하는 모든 명령은 사용자 프로그램이 아닌 OS를 통해서만 수행되도록 막아져있기 때문이다.
                 이후 OS는 device controller에게 해당 작업을 시킨다. I/O 작업은 주로 오래 걸리기 때문에, OS는 CPU를 다른 사용자 프로그램에게 할당해주고, CPU는 다시 메모리 관련 작업을 진행한다.
                 그리고 I/O 작업이 완료되면, device controller가 CPU에게 인터럽트를 걸고, CPU 제어권이 OS에게 넘어가, OS는 인터럽트의 이유를 확인한다. 이전에 요청한 I/O가 완료되었다는 것을 확인하고, local buffer에 있는 값을
                 프로그램 메모리 공간에 저장하고, 방금 선점 당한 프로그램에게 다시 CPU를 돌려준다.
                 만약 입력 받는 값을 이후 로직에서 이용해야 해서 더이상 일을 수행하지 못하면, 다른 프로그램으로 CPU가 넘어간다.
            - 2. Timer       
                 특정 프로그램이 CPU를 독점하는 것을 막고, time-sharing을 구현하기 위해 Timer라는 하드웨어 장치를 사용한다. OS가 사용자 프로그램에 CPU를 할당하기 전에 Timer에 최대 사용시간을 세팅한다. 그리고 CPU를 그 시간 이상 사용하게 되면
                 Timer가 CPU에게 인터럽트를 걸어서 알려준다.
                 그리고 Timer 인터럽트가 도착하면 CPU에 대한 제어권이 사용자 프로그램에서 OS로 넘어가게 된다.
                 OS가 CPU를 얻게되면, 다른 프로그램에게 넘겨주는데, 이때도 마찬가지로 timer에 시간을 세팅하고 넘겨준다.

- **Memory** : CPU의 작업공간. CPU가 클럭 사이클마다 메모리로부터 명령을 인출하고 실행
    - Memory controller
- I/O Device : 데이터 입출력을 위한 장치 (ex. 키보드, 모니터, 프린터, 하드디스크)
    - 하드디스크 : 데이터를 메모리로 읽어들이기도 하고, 처리결과를 디스크에 저장하기도 한다.
    - Device Controller(하드웨어) : 해당 I/O Device를 관리하는 일종의 작은 CPU. CPU가 어떤 I/O 일을 시킬지 구분하기 위한 제어 정보를 위해 control register, status register를 갖고 있으며, 입출력 데이터를 위한 임시 공간으로 local buffer를 갖는다.
    - Device driver(소프트웨어) : OS 코드중 각 디바이스를 접근하기위한 인터페이스가 있는데, 이것에 맞춰서 디바이스에 접근할 수 있게 해주는 소프트웨어 모듈로 이것을 설치해야 디바이스에 접근가능. 입출력 명령을 내릴 때도, 디바이스 드라이버를 통함
- Timer : CPU를 특정 프로그램이 독점하는 것으로부터 보호하기 위한 장치이며, 정해진 시간이 흐른 뒤 타이머 값이 0이 되면, 운영체제에게 CPU 제어권이 넘어가도록 인터럽트를 발생시킴. OS는 Timer의 도움을 받아 여러 프로그램을 번갈아 실행할 수 있음
- DMA Controller : 원래 메모리에 접근 가능한 장치는 CPU 밖에 없다. 그래서 I/O 작업중 메모리 접근이 필요한 경우,
  CPU에 인터럽트를 걸어, CPU가 메모리 내용을 local buffer로 옮기거나 local buffer 내용을 메모리에 옮긴다. 하지만, 키보드 입력이 1byte 단위로 들어올 때마다 CPU가 매번 인터럽트를 받고, OS로 넘어가 local buffer 데이터를 메모리로 저장하는 과정을 반복하면 오버헤드가 크다는 문제가 생긴다.
  따라서 DMA가 대신 CPU 중재 없이 블럭 단위로 device의 local buffer에 있는 내용을 메모리로 복사 해준다.
  그리고 블럭 단위 작업이 끝나면 CPU에 인터럽트를 한번만 걸어서 모든 내용이 메모리로 옮겨졌다는 것을 보고한다. 이로써 CPU는 계속 자기일을 할 수 있고, 인터럽트 받는 빈도 수도 줄어든다.

### 입출력(I/O)의 수행
- 모든 입출력 명령은 특권 명령(커널 모드에서 수행 가능)
- 사용자 프로그램은 어떻게 I/O를 하는가? -> 시스템콜을 통해 OS에게 요청
    - 시스템콜
        - 운영 체제의 커널이 제공하는 서비스에 대해, 사용자 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스. 일반적인 함수와 다른 것은 시스템 콜을 호출할 때, 이때 트랩을 발생시켜, CPU가 OS로 넘어가게 한다.
        - 이유) CPU에서 명령을 순차적으로 실행하다가 제어문이나 함수호출에 의해 주소 점프를 할 수 있지만,
          I/O 요청을 위해 커널 함수를 호출해야 하는 경우, 모드빗 1이기 때문에 단순히 커널 영역으로 주소 점프할 수 없다. 따라서 사용자 프로그램이 소프트웨어 인터럽트라인을 세팅함.
          CPU는 명령을 실행하고나서 인터럽트라인을 체크하고, 모드빗은 0으로 바뀌고 OS로 제어권 넘어가. OS 는 deveice controller에게 I/O를 요청하게된다.
          I/O 일을 하면, CPU가 다른 프로그램에 넘어가고, 끝나면 이번에는 device controller에 의해 하드웨어 인터럽트가 발생.
- I/O를 위해서는 인터럽트가 2번 발생한다.
    - 사용자 프로그램이 I/O 작업 요청시 : 시스템콜을 하면서, 소프트웨어 인터럽트 발생
    - I/O 작업 완료시 : device controller -> CPU로 하드웨어 인터럽트 발생


### 인터럽트(interrupt)
- 인터럽트 당한 시점의 레지스터와 PC를 저장한 후, CPU의 제어를 인터럽트 처리 루틴에 넘긴다. OS는 인터럽트 발생시에만 CPU를 사용하고, 그외에는 사용자 프로그램이 CPU를 사용한다.
- 하드웨어 인터럽트(interrupt, 일반적인 인터럽트) : Timer나 Device controller같은 하드웨어가 발생시킨 인터럽트
- 소프트웨어 인터럽트(Trap)
    - Exception : 프로그램이 오류를 범한 경우(0으로 나눈 경우, OS 메모리에 접근하는 경우 등)
    - System call : 사용자 프로그램이 필요에 의해 OS의 서비스를 요청하는 것

- 인터럽트 용어
    - 인터럽트 벡터 : 각각의 인터럽트 종류별 번호와 처리 루틴 주소를 쌍으로 가지고 있음
    - 인터럽트 처리 루틴(핸들러) : 해당 인터럽트를 처리하는 커널 함수


### 동기식 입출력(synchronous I/O)
- OS에 I/O 요청 후 입출력 작업이 끝날 때까지 기다린 후, 완료가 되면 그 다음 명령을 수행
- CPU를 가지고 있는지는 중요하지 않음

- 구현방법 1
    - I/O가 끝날 때까지 CPU를 가지고 기다리며 낭비시킴
    - 매시점 하나의 I/O만 일어날 수 있음
- 구현방법2 (일반적)
    - I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
    - I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
    - 다른 프로그램에게 CPU를 줌
    - 여러 I/O가 동시에 일어날 수 있음

### 비동기식 입출력(asynchronous I/O)
: OS에 I/O 요청 후 입출력 작업이 끝나기를 기다리지 않고 곧바로 제어가 사용자 프로그램에 즉시 넘어가서 I/O와 무관한 작업을 계속 진행

<p align="center"><img src = "https://user-images.githubusercontent.com/67847920/152673621-e5749879-7236-4cdc-8588-4687f4c4ebbd.PNG" width="500"></p>
동기식/비동기식 모두 I/O의 완료는 device controller에서 인터럽트로 알려준다.


### 서로 다른 입출력 명령어
- I/O를 수행하는 special instruction
- Memory Mapped I/O

### 기억장치 계층 구조
Primary(Executable, CPU에서 직접 접근 가능한 기억장치)
1. Registers
2. Cache Memory
3. Main Memory (바이트 단위로 주소가 매겨져 있으며, CPU 또한 바이트 단위로 실행이 가능하다.)

Secondary(CPU에서 직접 접근 불가능한 기억장치)
4. Hard Disk (섹터 단위)

- 속도
  : 위로 갈수록 빠르다.
- 비용   
  : 위로 갈수록 비싸기 때문에 용량이 적다.
- 휘발성
  : 하드디스크는 전원이 나가도 데이터가 사라지지 않는다. 반면에 Primary 기억장치는 전원이 나가면 데이터가 사라진다.

Caching : 재사용을 위해 더 빠른 기억장치에 데이터를 복사해 놓는 것. 하지만, 더 위로 갈수록 용량이 작기 때문에 모든 데이터를 상위 기억장치에 저장할 수는 없다.

### 프로그램의 실행
1. File system
- 프로그램은 실행파일 형태로 하드디스크에 저장되어 있다.
- 이것을 실행하면 메모리에 올라가 프로세스가 되는 것이다.
2. Virtual Memory
- 프로그램을 실행하면, 0번지 부터 시작하는 그 프로그램만의 독립적인 주소공간을 할당 받는다.
- code, data, stack
3. Physical Memory
- 커널 영역은 부팅 후, 항상 존재한다.
- 사용자 프로그램 실행 시, 생성되는 주소공간이 물리 메모리에 올라가는데, 다 올리는 것은 아니고 당장 필요한 부분만 올라간다.
- 그리고 필요 없어지면, 메모리에서 제거하여 디스크의 swap area에 저장한다.
- 즉, 가상 메모리는 프로그램에서 논리적으로 접근하기 위한 가상의 주소공간일 뿐,
  실제로 연속적으로 존재하는 것이 아니며, 어떤 영역은 물리메모리에 있을 수 있지만, 어떤 영역은 디스크의 swap area 존재할 수 있다.
- 논리 메모리 주소를 물리 메모리 주소로 변환하는 과정이 필요하다.
4. Swap area
- 메모리 공간의 한계로 인해 메모리 연장 공간으로 사용하는 목적
- File system도 하드디스크고, swap area도 하드디스크지만, 용도가 다르다.
    - File system은 비휘발성 용도로 사용되지만,
    - Swap area의 데이터는 전원이 나가면, 의미 없는 데이터가 된다.

### 커널 주소 공간의 내용
- **code**(커널 코드)
    - 자원 관리를 위한 코드
    - 시스템 콜, 인터럽트 처리 코드
        - OS는 인터럽트 발생 시마다 CPU를 얻기 때문에, 각 인터럽트에 대한 처리 루틴이 들어 있다.
    - 편리한 서비스 제공을 위한 코드
- **data**
    - CPU, Memory, Disk 같은 하드웨어를 관리하기 위한 자료구조
    - PCB(프로세스마다 관리하기 위한 자료구조)
- **stack**
    - 프로세스 커널 스택
    - 사용자 프로그램이 시스템 콜을 통해 OS의 코드를 실행시킬 수 있기 때문에, 어던 프로세스가 커널의 코드를 실행중인지 알기 위해
      커널 스택을 프로세스마다 유지하고 있다.

### 프로세스에서 사용하는 함수
<p align="center"><img src = "https://user-images.githubusercontent.com/67847920/152673808-2f7d0adc-d4bd-4de2-8490-af37ebab9307.PNG" width="500"></p>

- 사용자 정의 함수/라이브러리 함수는 컴파일하여 실행파일을 만들면, 그 안에 들어가게 된다. 따라서 프로세스 주소공간의 code 영역에 존재한다.
- 반면에, 커널 함수는 커널 주소공간에 존재하며, 사용자 프로그램에서 호출하기 위해서는 시스템 콜을 통해야한다.
- 프로그램은 사용자 모드로 실행하다 시스템 콜에 의해 커널 모드로 바뀌고, 다시 사용자 모드로 리턴되어 반복하며 실행하다가 끝난다.
- 주소 점프는 하나의 가상 메모리 안에서의 점프를 의미하는 것이지, 물리메모리 상에서 사용자 영역 -> 커널 영역으로 점프는 불가능하다.  


[< 뒤로](../README.md)
