# 스레드
- 프로세스내에서 CPU 수행의 기본 단위

### 스레드의 구성
<p align="center"><img src = "https://user-images.githubusercontent.com/67847920/153741306-3b19c622-bb6f-4a7b-a0e9-56ab2239e50e.PNG" width="400"></p>
<p align="center"><img src = "https://user-images.githubusercontent.com/67847920/153741320-d308ca42-4aa3-429f-8f95-48a218536816.PNG" width="400"></p>

- PC
- registers
- stack
  

- 스레드가 공유하는 부분(=task)
  - code
  - data
  - os resources

*스레드가 여러 개이면*
  - PCB에서는 cpu 관련 정보(PC, registers)만 스레드별로 별도로 갖는다.
  - 주소공간에서는 stack만 별도로 갖는다.

### 스레드의 특징
- 동일한 작업을 수행하는 프로세스가 여러 개이면 프로세스마다 별도의 주소공간을 만들게 되고, 메모리를 낭비하게 된다.
- 프로세스를 여러개 띄우기 보다는 주소공간은 하나를 공유하면서, 각각 다른 부분의 코드를 수행하는 것이 스레드 개념이다.
- 스레드는 하나의 프로세스 안에서, PC와 레지스터를 여러 개 두어 CPU 수행 단위만 여러 개 갖는 것이다.
- 스레드가 PC가 가리키는 곳을 실행하다가 함수 호출을 하면, 관련 정보를 스레드별 스택에 저장한다.
- 스레드는 하나의 프로세스 안에서 공유할 수 있는 것은 최대한 공유하고, CPU 수행과 관련된 정보(pc, regs, stack)만 별도로 갖는다. 
- 프로세스를 여러개 두는 것보다 하나의 프로세스에 여러 스레드를 두는 것이 더 가볍기 때문에, 스레드를 lightweight process라고도 한다.
- 하나의 스레드만 갖고 있는 전통적인 개념의 프로세스 = heavyweight process


### 스레드의 장점
- 응답성(Responsiveness)이 빨라진다.
  - 하나의 프로세스에 여러 개의 스레드를 두면, 하나의 서버 스레드가 blocked(waiting) 상태인 동안에도 동일한 태스크 내의 다른 스레드가 CPU를 잡고
  실행(running)되어 빠른 처리를 할 수 있다. -> 응답시간이 빨라짐
  - 네트워크를 통해 웹 페이지를 읽어오는 것은 I/O 작업으로 즉, 오래 걸리는 작업이다. 이때, 네트워크를 통해 웹 페이지를 요청하는 역할의 스레드와 디스플레이해주는 역할의 스레드를 별도로 두어 응답성을 높일 수 있다.
    - *예시)*
      - 웹 브라우저에서 naver.com를 들어가면, HTML을 받아 디스플레이를 하려고 보니 이미지가 필요한 상황  
      - HTML을 받은 후에 웹 브라우저가 다시 웹 서버에 이미지를 요청하면, 오래 걸리는 작업이므로 브라우저는 blocked 상태가 된다.
      - 웹 페이지의 모든 이미지를 읽어올 때까지 프로세스는 blocked 상태이기 때문에, 그동안 화면에 디스플레이되는 것이 없어서 사용자 입장에서 답답할 수 있다. 이미지를 받으면, 그제서야 텍스트 + 이미지 합쳐서 보여준다.  
      - 웹 브라우저가 멀티 스레드로 동작하면, HTML을 받고 이미지를 다시 요청하더라도, 해당 스레드는 block 되지만, 다른 스레드가 먼저 읽어온 HTML이라도 디스플레이하여 응답성을 높일 수 있고, 사용자는 덜 답답할 것이다.
      - 비동기식 입출력이라 할 수 있다.
        - 이미지를 읽어오는(I/O작업) 동안에 프로세스를 block시키는게 아니고, I/O가 끝나기 전에 CPU를 얻어서 이미지와 무관한 HTML을 먼저 디스플레이 해주는 것.
- 자원을 공유
  - 같은 작업을 하는 프로세스를 여러 개 실행하면, 저마다 주소공간을 할당받아 메모리 낭비가 심하다. 
  - 하나의 프로세스 안에 같은 작업을 하는 스레드를 여러개 두면, code, data, 그외 프로세스 자원을 공유하기 때문에, 메모리 관점에서 효율적이다.
- economy
  - '프로세스 생성 & 프로세스간 문맥 교환' 오버헤드가 '스레드 생성 & 스레드간 문맥 교환' 오버헤드보다 훨씬 크다. 
  - 프로세스간 문맥 교환은 CPU 관련 정보를 저장하고 불러오는 것뿐만 아니라 캐시 메모리 flush도 발생하기 때문에 오버헤드가 크다. 
  - 프로세스내에서 스레드간 문맥 교환은 간단하다. 같은 주소공간을 쓰기 때문에 대부분의 문맥을 그대로 사용하고, CPU 수행 관련 정보만 교환이 일어난다.
  - 따라서, 같은 일을 하는 작업의 경우 프로세스 만드는 것보다 스레드 만드는게 효율적이다.
- 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율과 성능 향상을 얻을 수 있다.
- 병렬성
  - Multi-processor 환경이면, 각 스레드들이 서로 다른 CPU에서 병렬적으로 실행이 되어 성능을 높일 수 있다.
  - ex) 큰 행렬의 곱셈
  
### 스레드의 구현
- 어떤 스레드는 Kernel의 지원을 받아 구현하기도 하고, 다른 어떤 스레드는 라이브러리를 통해 구현되기도 한다.
- 커널 스레드
  - 스레드가 여러개 있다는 사실을 Kernel의에서 알고 관리한다. 그래서, 커널이 스케줄링하여 하나의 스레드에서 다른 스레드로 CPU를 넘겨준다.
- 유저 스레드
  - Kernel은 프로세스 안에 스레드가 여러 개 있다는 사실을 알지 못하고 일반적인 프로세스로 보지만, 사용자 프로그램이 스스로 라이브러리로 지원받아 여러 스레드를 관리하는 것이다.
