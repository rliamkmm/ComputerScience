[< 뒤로](../README.md)


# Hash(해시)

### 특징
- O(1) 의 탐색 연산을 가진 자료구조
- 저장되는 데이터는 키와 값이 하나의 쌍을 이루며, 모든 키는 중복되지 않는다.
- '키의 해시값은 저장위치'라는 관계를 형성하여, 배열을 테이블로 사용하면 단번에 데이터를 저장하고 탐색할 수 있다.

### 문제점
- 키의 범위가 굉장히 클 경우 테이블을 구성하려면 그만큼 큰 배열이 필요하다.  

### 해결 방법
- 해시함수를 이용한다. 해시함수는 임의 크기 데이터를 고정 크기 값으로 매핑하는데 사용하는 함수이다. 

**좋은 해시함수의 조건**
- 데이터가 테이블의 전체 영역에 고루 분포하도록 하는 해시함수. 즉, 충돌이 발생할 확률이 낮은 해시함수이다.
- 충돌의 해결책이 마련되어 있다 하더라도 충돌은 덜 발생할 수록 좋다.
- 사실 좋은 해시함수는 키의 특성에 따라 달라진다. 하지만 일반적으로 좋은 해시함수는 키의 일부분을 참조하여 해시값을 만들지 않고, 키 전체를 참조하여 해시값을 만들어낸다.


### 또 다른 문제점
- 충돌이 발생할 수 있다. 
  - 서로 다른 두 개의 키가 해시함수를 통과하였는데, 해시값이 같은 상황
- 이러한 충돌은 배열의 길이를 늘리는식으로 피해야하는 것이 아닌 해결해야하는 것이다.
- 충돌의 해결 방법에 따라 테이블의 구조가 달라질 수 있다.

## 충돌 해결방법
### open addressing method
- 충돌이 발생하면, 충돌이 발생한 그 자리(버킷)를 대신해서 빈 자리를 찾아야 한다. 다만 빈 자리를 찾는 방법에 따라서 해결책이 구분된다.


- **선형 조사법**
  - 충돌이 발생했을 때, 그 옆자리가 비어있는지 살펴보고, 비어있을 경우 그 자리에 대신 저장하는 방법
  - 물론 옆자리가 비어있지 않을 경우, 한 칸 더 이동해서 조사
  - 선형 조사법은 충돌의 횟수가 증가함에 따라서 '**클러스터 현상**'이 발생한다는 단점이 있다. 
    그리고 이러한 클러스터 현상은 충돌의 확률을 높이는 직접적인 원인이 된다. 
    이것을 조금이라도 극복하기 위해 이차 조사법을 사용할 수 있다.
    - *클러스터 현상: 해시테이블에 데이터들이 고르게 분포되지 않고 여기저기에 뭉쳐있는 데이터 그룹이 생기는 현상*
- **이차 조사법**
  - 선형 조사법과 달리 충돌이 발생했을 때, 한 칸이 아니라 N^2 만큼 옆을 조사한다. 즉, 좀 멀리서 빈 자리를 찾으려는 노력이 담겨있다. 
  - 클러스터 현상이 그나마? 완화되지만, 해시값이 같으면 충돌 발생시 빈 자리를 찾기 위해서 접근하는 위치가 늘 동일하다는 문제가 있다.
  - 이 때문에 선형 조사법만큼은 아니지만 접근이 진행되는 공간을 중심으로 클러스터 현상이 발생할 확률은 여전히 높다.
- **이중 해시(이상적인 충돌 해결책)**
  - 이중 해시를 이용하면, 클러스터 현상의 발생 확률을 현저히 낮출 수 있다.
  - 이름 그대로 두개의 해시 함수(1차,2차)를 이용하는 방법이다. 1차 해시함수는 키를 근거로 저장위치를 결정하기 위한 용도이며, 2차 해시함수는 충돌 발생시 몇 칸 뒤를 살필지 결정하기 위한 것이다.
  - 즉, 충돌 발생시 조사 순서는 다음과 같다.
    - h1(k) -> h1(k) + h2(k) * 1 -> h1(k) + h2(k) * 2 -> ...
  - 이처럼 2차 해시값의 크기 만큼 건너 뛰면서 빈 자리를 찾는다.
  
- open addressing method는 버킷 사이즈보다 데이터 개수가 많아지면 삽입할 수 없기 때문에, 기준이 되는 로드 팩터를 넘어서면, 더 큰 크기의 또 다른 버킷을 생성한 후 새롭게 복사하는 리해싱 작업이 필요하다.
  - *로드 팩터: 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈 것 (n/k)*
- 로드 팩터 비율에 따라 해시 함수를 재작성해야 될지 또는 해시 테이블의 크기를 조정해야 할지를 결정한다.
- 일반적으로 로드 팩터가 증가할수록 해시 테이블의 성능은 점점 감소하기 때문에, 자바의 경우 0.75를 넘기면 동적 배열처럼 해시 테이블의 공간을 재할당한다.

### closed addressing method
- open addressing method처럼 다른 자리에 대신 저장하는 것이 아닌 무슨 일이 있어도 자신의 자리에 저장하는 방법이다.
- 이것이 가능하기 위해서 배열이나 연결 리스트를 이용하여 자리를 여러 개 마련한다. 배열을 사용할 경우 충돌이 발생하지 않을 경우 메모리 낭비가 심하다는 점과 충돌의 최대 횟수를 결정해야 하는 부담도 있다.
- 따라서 연결 리스트를 이용해서 슬롯을 연결하는 방법이 대표적이다. 이것을 'separate chaining'이라 한다.
  
**separate chaining(개별 체이닝)**
1. 키의 해시값을 계산한다.
2. 해시값을 이용해 배열의 인덱스를 구한다.
3. 같은 인덱스가 있다면 연결 리스트로 연결한다.
- 탐색 시간이 최선의 경우 O(1), 최악의 경우 O(N)이 걸린다.
- 자바 8에서는 데이터의 개수가 많아지면 레드-블랙 트리에 저장하는 형태로 병행해 사용하기도 했다.
- chaining 방법의 단점은 동일한 해시값으로 묶여있는 연결된 슬롯을 모두 조사해야 한다는 점이다.


[< 뒤로](../README.md)
